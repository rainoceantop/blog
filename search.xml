<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[matplotlib的使用]]></title>
    <url>%2Fblog%2F2018%2F05%2F22%2Fmatplotlib%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Matplotlib 是一个 Python 的 2D绘图库，它以各种硬拷贝格式和跨平台的交互式环境生成出版质量级别的图形 。通过 Matplotlib，开发者可以仅需要几行代码，便可以生成绘图，直方图，功率谱，条形图，错误图，散点图等。开发者：John D. Hunter matplotlib 安装：pip install matplotlib 画图 导入 import matplotlib.pyplot as plt画线 plt.plot(x, y) plt.plot([1, 2, 3], [5, 7, 4], label=&#39;first graph&#39;)画日期线 plt.plot(x, y)画柱状图 plt.bar(x, y, label=&#39;first bar&#39;, color=&#39;#FFE4C4&#39;)画直方图(统计范围内符合的数量) plt.hist(x, y, histtype=&#39;bar&#39;, label=&#39;first histogram&#39;, rwidth=0.8)画分散图 plt.scatter(x, y, label=&#39;first scatter&#39;, marker=&#39;*&#39;, s=100)画堆栈图 days = [1, 2, 3, 4, 5, 6, 7] sleeping = [8, 8, 8, 8, 8, 10, 10] eating = [2, 2, 2, 2, 2, 2, 2] working = [8, 8, 8, 8, 8, 2, 2] playing = [6, 6, 6, 6, 6, 10, 10] #python这个库不带堆栈图标记，自己创建唯标记 plt.plot([], [], color=&apos;#7AC5CD&apos;, label=&apos;Sleeping&apos;, linewidth=5) plt.plot([], [], color=&apos;#FAEBD7&apos;, label=&apos;Eating&apos;, linewidth=5) plt.plot([], [], color=&apos;#9AFF9A&apos;, label=&apos;Working&apos;, linewidth=5) plt.plot([], [], color=&apos;#FFF68F&apos;, label=&apos;Playing&apos;, linewidth=5) plt.stackplot(days, sleeping, eating, working, playing, colors=[&apos;#7AC5CD&apos;, &apos;#FAEBD7&apos;, &apos;#9AFF9A&apos;, &apos;#FFF68F&apos;]) 画扇形图 slices = [8, 2, 8, 6] activities = [&apos;sleeping&apos;, &apos;eating&apos;, &apos;working&apos;, &apos;playing&apos;] colors = [&apos;#7AC5CD&apos;, &apos;#FAEBD7&apos;, &apos;#9AFF9A&apos;, &apos;#FFF68F&apos;] plt.pie(slices, labels=activities, colors=colors, startangle=90, shadow=True, explode=[0, 0.1, 0, 0], autopct=&apos;%1.1f%%&apos;) 颜色作为参数color传进画图函数里x-轴命名 plt.xlabel(&#39;quality&#39;)y-轴命名 plt.ylabel(&#39;amount&#39;)图表名称 plt.title(&#39;quality-amount statistics\ncheck it out&#39;)显示标记 plt.legend()显示 plt.show() 读取文件 读取csv文件 import csv x = [] y = [] with open(&apos;example.txt&apos;, &apos;r&apos;) as csvfile: plots = csv.reader(csvfile, delimiter=&apos;,&apos;) for row in plots: x.append(int(row[0])) y.append(int(row[1])) plt.plot(x, y, label=&apos;loaded from file!&apos;) 使用numpy读取txt文件 # 正常情况下将返回一个二维矩阵，设置unpack=True后返回各列 x, y = np.loadtxt(&apos;example.txt&apos;, delimiter=&apos;,&apos;, unpack=True) plt.plot(x, y, label=&apos;loaded from file!&apos;) 自定义 设置图内标签 ax1.legend() leg = legend(loc=9, ncol=2, prop={&apos;size&apos;:11}) # loc定义位置参数，ncol表示显示列数，prop传递各种参数 leg.get_frame().set_alpha(0.4) # 设置透明度 标签旋转 #需要将图形变成网格并赋予一个变量的时候才能使用 ax1 = plt.subplot2grid((3, 2), (2, 0), colspan=2) for label in ax1.xaxis.get_ticklabels(): label.set_rotation(90) 显示网格：ax1.grid(True, color=&#39;green&#39;, linestyle=&#39;-&#39;, linewidth=&#39;2&#39;)调整图形位置：plt.subplots_adjust(bottom=0.45)改变x/y轴标签颜色：ax1.xaxis.label.set_color(&#39;c&#39;) ax1.yaxis.label.set_color(&#39;r&#39;)设置x/y轴坐标间隔：ax1.set_xticks([]) ax1.xaxis.set_ticks([]) ax1.set_yticks([]) ax1.yaxis.set_ticks([])填充颜色：ax1.fill_between(thetime, price, price[0], facecolor=&quot;g&quot;, alpha=0.3)操作坐标轴：ax1.spines[&#39;left&#39;].set_color(&#39;g&#39;) ax1.spines[&#39;right&#39;].set_visible(False) ax1.spines[&#39;left&#39;].set_linewidth(5)修改坐标轴时间格式：ax1.xaxis.set_major_formatter(mdates.DateFormatter(&quot;%Y-%m-%d&quot;))修改坐标轴间隔：ax1.xaxis.set_major_locator(mticker.MaxNLocator(5))参数操作x/y轴：ax1.tick_params(axis=&#39;x&#39;, colors=&#39;g&#39;)操作水平/垂直线：ax1.axhline(price[0], color=&#39;k&#39;, linewidth=5) ax1.axvline(thetime[0], color=&#39;k&#39;, linewidth=5)限制坐标轴：ax2v.set_ylim(0, 5*max(y)) #按原来的y轴的1/5缩放共享坐标轴： ax2 = plt.subplot(212, sharex=ax1)使用样式 from matplotlib import style style.use(&apos;ggplot&apos;) style.use(&apos;fivethirtyeight&apos;) print(plt.style.available) 嵌入文字 font_dict = {&apos;family&apos;: &apos;serif&apos;, &apos;color&apos;: &apos;darkred&apos;, &apos;size&apos;: 20} ax1.text(float(xs[5]), float(ys[5]), &apos;555&apos;, fontdict=font_dict) (标签的类型一定要相同) 获取文件位置：print(plt.__file__) 同步更新数据 示例代码 from matplotlib import animation fig = plt.figure() ax1 = fig.add_subplot(1, 1, 1) # 写一个获取数据的函数 def animate(i): graph_data = open(&apos;example.txt&apos;, &apos;r&apos;).read() lines = graph_data.split(&apos;\n&apos;) xs = [] ys = [] for line in lines: if len(line) &gt; 1: x, y = line.split(&apos;,&apos;) xs.append(x) ys.append(y) ax1.clear() ax1.plot([float(a) for a in xs], [float(b) for b in ys]) # 每过一秒更新一次 ani = animation.FuncAnimation(fig, animate, interval=1000) plt.show() 箭头指向(x，y轴的标签类型要一致)： ax1.annotate(&apos;bad news&apos;, (float(xs[6]), float(ys[6])), xytext=(0.8, 0.9), textcoords=&apos;axes fraction&apos;, arrowprops=dict(facecolor=&apos;grey&apos;, color=&apos;grey&apos;)) 显示最后一个值： bbox_props = dict(boxstyle=&apos;round&apos;, fc=&apos;w&apos;, ec=&apos;k&apos;, lw=1) ax1.annotate(ys[-1], (float(xs[-1]), float(ys[-1])), xytext=(float(xs[-1]), float(ys[-1])), bbox=bbox_props) 分布式格局(使用时添加的标签，标题等要对应在每个图形的上/下面) 创建网格 # 第一个数字（参数）为分割行数，第二个为分割列数，第三个为第几个网格作为图形展示 ax1 = fig.add_subplot(221) # 两行两列选第一个 ax2 = fig.add_subplot(222, sharex=ax1) # 两行两列选第二个，共享ax1的x坐标轴 ax2v = ax2.twinx() # 共用x坐标轴 ax3 = fig.add_subplot(212) # 两行一列选第二个 # 图形被分割成3行，2列的网格，后面的plot的位置在第三行第一列（默认第一行/列为0，左上角向下延伸） plt.subplot2grid((3, 2), (2, 0), colspan=2).plot([0, 1, 2, 3], [10, 20, 30, 15]) 其他 3D图形 import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D import numpy as np # 设置三维坐标 fig = plt.figure() ax = Axes3D(fig) # 生成数据 x = np.linspace(-5, 5, 200) y = np.linspace(-5, 5, 200) X, Y = np.meshgrid(x, y) # XY平面的网格数据 Z = (1 - X / 2 + X ** 7 + Y ** 5) * np.exp(-X ** 2 - Y ** 2) # 画3d图 ax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap=plt.cm.jet) # ax.plot_surface(X,Y,z,rstride=1,cstride=1,cmap=plt.get_cmap(&apos;rainbow&apos;)) # 等高线图 ax.contourf(X, Y, Z, zdir=&apos;z&apos;, offset=-2, cmap=&apos;rainbow&apos;) # zdir= x/y/x 轴的等高线 offset=等高线的位置 plt.show() 正确的matplotlib时间格式： ① 数字类型：20171218 1.用strpdate2num创建转换器：converter = mdates.strpdate2num(&quot;%Y%m%d&quot;) 2.将数组里面的所有值用该转换器转换重新赋值：x = [converter(i) for i in x] 3.用plot_date显示 ② 时间戳类型： 1.用np创建转换器：converter = np.vectorize(datetime.datetime.fromtimestamp) 2.转换x：x = converter(x) 保存图片：fig.savefig(&#39;test.png&#39;, facecolor=fig.get_facecolor())]]></content>
      <categories>
        <category>python</category>
        <category>matplotlib</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pandas的使用]]></title>
    <url>%2Fblog%2F2018%2F05%2F22%2Fpandas%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Pandas是python的一个数据分析包，最初由就职于AQR Capital Management的Wes McKinney于2008年4月开发，并于2009年底开源出来，目前由专注于Python数据包开发的PyData开发team继续开发和维护，属于PyData项目的一部分。Pandas最初被作为金融数据分析工具而开发出来，因此，pandas为时间序列分析提供了很好的支持。 Pandas的名称来自于面板数据（panel data）和python数据分析（data analysis）。panel data是经济学中关于多维数据集的一个术语，在Pandas中也提供了panel的数据类型。开发者：Wes McKinney 创建序列 s = pd.Series([1, 3, 6, np.nan, 44, 1]) # 打印的时候会显示下标索引，默认类型float64或float32 创建日期范围数组 dates = pd.date_range(&apos;20171106&apos;, periods=7) # 7天的日期数组 pd.Timestamp(&apos;20171106&apos;) # 创建单个时间 创建数据表格及表格操作 # index为行的索引，column为列的索引，如不指定，行和列默认0开始索引 df = pd.DataFrame(np.random.randn(7, 4), index=dates, columns=[&apos;r1&apos;, &apos;r2&apos;, &apos;r3&apos;, &apos;r4&apos;]) df2 = pd.DataFrame({ &apos;A&apos;: 1., &apos;B&apos;: pd.Timestamp(&apos;20171106&apos;), &apos;C&apos;: 3, &apos;D&apos;: pd.Categorical([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]), &apos;E&apos;: &apos;food&apos;}) 获取表格每一列的类型：print(df2.dtypes) 获取每一行的索引：print(df.index) 获取每一列的索引：print(df.columns) 获取表格数据：print(df.values) 将表格行列倒置：print(df.T) 计算表格中的数据：df.describe() 对行的索引排序：df.sort_index(axis=1, ascending=False) # ascending=False时表示倒序 对列的索引排序：df.sort_index(axis=0, ascending=False) # ascending=False时表示倒序 对列的值排序：df.sort_values(by=&apos;r4&apos;) 获取列：df[&apos;r3&apos;] 或者 df.r3 切片获取行：df[0:1] 或者 df[dates[0]:dates[1]] # 根据标签索引 select by label 具体索引获取行：df.loc[dates[0]] 具体索引筛选行和列：df.loc[:, [&apos;r3&apos;, &apos;r4&apos;]] # 根据index索引 select by index 根据索引下标获取数据：df.iloc[1:3, 1:3] df.iloc[[1, 3, 5], 1:3] # 混合索引 select by ix 用标签和index混合筛选数据：df.ix[1:3, [&apos;r3&apos;, &apos;r4&apos;]] # 根据boolean索引 boolean indexing 用判断的方式进行筛选：df[df.r3 &gt; 1] 修改表格数据 df.iloc[2, 2] = 11 df.loc[dates[0], &apos;r3&apos;] = 11 df.r1[df.r1 &gt; 1] = 0 添加列：df[&apos;r5&apos;] = np.nan 处理表格数据 # 当how等于any的时候，只要包含一个nan的，就删除，如果改为all，则需要行内所有值都为nan的时候才删除 删除包含nan的表格的行：df.dropna(axis=0, how=&apos;any&apos;) # how={&apos;all&apos;, &apos;any&apos;} 删除包含nan的表格的列：df.dropna(axis=1, how=&apos;any&apos;) 填充包含nan的表格的数据：df.fillna(value=0) 判断表格的数据是否为nan：df.isnull() 判断表格至少存在一个nan丢失数据：np.any(df.isnull()) 合并表格 df1 = pd.DataFrame(np.ones((3, 4)) * 0, columns=[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]) df2 = pd.DataFrame(np.ones((3, 4)) * 1, columns=[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]) df3 = pd.DataFrame(np.ones((3, 4)) * 2, columns=[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]) # ingnore_index=True表示忽略原来的索引，用数字有序的索引替代 同列栏目向下合并： pd.concat([df1, df2, df3], axis=0, ignore_index=True) df1.append([df2, df3], ignore_index=True) 同行栏目向右合并：pd.concat([df1, df2, df3], axis=1, ignore_index=True) # join,[&apos;inner&apos;,&apos;outer&apos;] 裁剪掉不同行/列后合并：pd.concat([df1, df2, df3], join=&apos;inner&apos;, ignore_index=True) # join_axes 根据某个表的行索引进行合并（没有该索引下表的其他表合并后用NaN表示）： pd.concat([df1, df2, df3], join_axes=[df1.index], axis=1, ignore_index=True) # merge高级合并 根据column进行合并：pd.merge(df1, df2, on=&apos;key&apos;, suffixes=[&apos;_left&apos;, &apos;_right&apos;], indicator=True) # 显示合并方式，将true换为一个字符串，可为该列命名，suffixes可为相同名称的列加后缀名 多个column进行合并：pd.merge(df1, df2, on=[&apos;key&apos;, &apos;key1&apos;], how=&apos;inner&apos;) # how默认为inner，共有四种选择【&apos;inner&apos;,&apos;outer&apos;,&apos;left&apos;,&apos;right&apos;】 # left_index 和 right_index默认为none，设置为true之后将改变合并方式，从根据column合并换为行标签合并 根据行标签进行合并：pd.merge(df1, df2, left_index=True, right_index=True, indicator=True) 生成图表 import matplotlib.pyplot as plt data = pd.DataFrame(np.random.randn(1000, 4), columns=[&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;]) data = data.cumsum() data.plot() data.plot.scatter(x=&apos;A&apos;, y=&apos;B&apos;) 其他 读取csv文件：data = pd.read_csv(&apos;test.csv&apos;) 存储文件：data.to_pickle(&apos;test.pkl&apos;)]]></content>
      <categories>
        <category>python</category>
        <category>pandas</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[numpy的使用]]></title>
    <url>%2Fblog%2F2018%2F05%2F22%2Fnumpy%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[NumPy 是一个 Python 包。 它代表 “Numeric Python”。 它是一个由多维数组对象和用于处理数组的例程集合组成的库。Numeric，即 NumPy 的前身，是由 Jim Hugunin 开发的。 也开发了另一个包 Numarray ，它拥有一些额外的功能。 2005年，Travis Oliphant 通过将 Numarray 的功能集成到 Numeric 包中来创建 NumPy 包。 这个开源项目有很多贡献者。 创建数组 b = np.array([]) 将list a转成numpy数组 array = np.array(a) 定义numpy数组类型（位数越小，所占用的空间越小） array = np.array([[1, 2, 3], [4, 5, 6]], dtype=np.int64) 将numpy数组转成list a = array.tolist() 创建全部为0的数组 array = np.zeros((3, 4)) # (3, 4)定义三行四列 创建全部为1的数组 array = np.ones((3, 4), dtype=np.int16) # (3, 4)定义三行四列 创建全部为空的数组 array = np.empty((3, 5)) 创建一个有序的数组 array = np.arange(10, 20, 2) # 像range，从10到19，step = 2 创建一个有序的数组，并且定义形状 array = np.arange(12).reshape((3, 4)) 创建一个有规律的分段的数组 array = np.linspace(0, 10, 6).reshape((2, 3)) 获取数组的维度 print(array.ndim) 获取数组的形状（行列数）print(array.shape) 获取数组的元素总和 print(array.size) 获取数组的类型 print(array.dtype) 数组的运算 a = np.array([10, 20, 30, 40]) b = np.arange(4) 加法运算：c = a + b 减法运算：c = a - b 乘法运算：c = a * b 除法运算：c = a / b sin计算：np.sin(a) cos计算：np.cos(a) tan计算：np.tan(a) 数组的所有元素的和：a.sum() 或者 np.sum(a) 求中位数：np.median(a) 数组的所有元素的平均值：a.mean() 或者 np.mean(a) 数组里的最小值：a.min() 或者 np.min(a) 最小值的索引：a.argmin() 或者 np.argmin(a) 数组里的最大值：a.max() 或者 np.max(a) 最大值的索引：a.argmax() 或者 np.argmax(a) 行中的运算 总和 a.sum(axis=1) 或者 np.sum(a, axis=1) 最小值 a.min(axis=1) 或者 np.min(a, axis=1) 最小值的索引：a.argmin(axis=1) 或者 np.argmin(a, axis=1) 最大值 a.max(axis=1) 或者 np.max(a, axis=1) 最大值的索引：a.argmax(axis=1) 或者 np.argmax(a, axis=1) 列中的运算 总和 a.sum(axis=0) 或者 np.sum(a, axis=0) 最小值 a.min(axis=0) 或者 np.min(a, axis=0) 最小值的索引：a.argmin(axis=0) 或者 np.argmin(a, axis=0) 最大值 a.max(axis=0) 或者 np.max(a, axis=0) 最大值的索引：a.argmax(axis=0) 或者 np.argmax(a, axis=0) 判断数组的值 print(array &lt; 5) print(array == 5) print(array &gt; 5) 数组元素累加：a.cumsum() 或者 np.cumsum(a) 数组元素累差：np.diff(a) 获取数组非零行列索引：np.nonzero(a) 对数组进行排序：np.sort(a) 数组里行列倒置：np.transpose(a) 或者 a.T 将数组抹平 a.flatten() # flatten()为功能函数，直接将二维数组抹平，但如果要进行循环迭代，用flat迭代器也可以 限定最大最小值（所有超过范围的都取最大或最小值）：a.clip(10, 20) 或者 np.clip(a, 10, 20) 在行上面加一个维度：a[np.newaxis, :] 在列上面加一个维度：a[:, np.newaxis] 数组的合并 A = np.array([[1, 1, 1], [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]]) B = np.array([[2, 2, 2], [&apos;d&apos;, &apos;e&apos;, &apos;f&apos;]]) 垂直合并 np.vstack((A, B)) # 每个数组每一行每一行地装上去 水平合并 np.hstack((A, B)) # 每个数组同一行先合并再装上去 指定维度的合并 np.concatenate((A, B), axis=0) # 一维数组axis只能为0 数组的分割 A = np.arange(12).reshape((3, 4)) 对等分割行 np.split(A, 3, axis=0) 或者 np.vsplit(A, 3) 对等分割列 np.split(A, 2, axis=1) 或者 np.hsplit(A, 2) 不等分割行 np.array_split(A, 2, axis=0) 不等分割列 np.array_split(A, 3, axis=1) 二维数组的索引 普通索引： a[2][0] 同一中括号索引： a[2, 0] 切片索引 a[2, :] # 第三行所有数 a[:, 2] # 第三列所有数 a[2, 1:] # 第三行第一位之后的所有数 a[1:, 2] # 第三列第一位之后的所有数 a[2, 1:3] # 第三行第一位到第三位的所有数 迭代行 for row in a: print(row) 迭代列 for column in a.T: print(column) 将数组抹平后迭代 for item in a.flat: print(item) 二维数组的运算： a = np.array([[0, 2],[1, 3]]) b = np.arange(8).reshape((2, 4)) 普通乘法： c = a * b 矩阵乘法： d = np.dot(a, b) 或者 d = a.dot(b) 数组中的复制： a = np.arange(12) 浅复制（改变数组a或b的元素的值，其它的跟着改变） b = a # b是a，指向同一个物理位置 深复制（改变数组a或b的元素的值，其它的不改变） b = a.copy() # b不是a，分别享有各自的物理位置 随机数 创建一个0~1随机数构成的2行4列的数组： a = np.random.random((2, 4)) 生成6个随机数： np.random.rand(6) 返回一个具有正在分布的随机数构成的6行4列的数组： np.random.randn(6, 4) 其他 函数装配vectorize()使得其函数可以应用在numpy数组上 lencount = np.vectorize(lambda x: len(x)) np.nan： 生成一个类型为float的NaN的空字符]]></content>
      <categories>
        <category>python</category>
        <category>numpy</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git的基础命令]]></title>
    <url>%2Fblog%2F2018%2F05%2F21%2Fgit%E7%9A%84%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。 Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。开发者：Linus Torvalds（同时也是linux的开发者，他是神↓） 确定管理文件夹 cd进入到该文件夹 确定身份象征(提交任何修改使用)：git config --global user.name &quot;&quot; git config --global user.email &quot;&quot; 查看身份象征：git config user.name git config user.email 初始化git管理目录：git init 查看隐藏文件：ls -a 创建文件：touch 1.py 查看git管理库状态 查看普通状态：git status 查看修改状态：git status -s git工作流程图 添加可提交修改（commited）文件（stage） 提交单个文件：git add 1.py 提交所有文件：git add . 撤销提交的文件：git reset 1.py 提交文件 直接提交：git commit -m &quot;提交信息&quot; 直接提交并添加：git commit -am &quot;提交信息&quot;（已经管理库有的文件，新文件无法识别到） 提交文件至上次提交的分支：git commit --amend（上次分支） --no-edit（不修改-m信息） 打印git日志 直接打印：git log 简洁打印：git log --oneline 简洁图形打印： git log --oneline --graph 查看修改信息 查看已修改未添加的修改信息：git diff 查看已添加的修改信息：git diff --cached 查看已添加再修改文件的修改信息：git diff HEAD 修改当前的头分支：git reset --hard (分支id号或HEAD指针（HEAD@{0}）) reset是在unstage(已commit)和stage之间重置） 重置单个文件的内容信息：git checkout 分支id号 -- 1.py 分支 创建分支：git branch dev 或者 git checkout -b dev(创建并移动到该分支) 查看分支：git branch 切换分支：git checkout dev 删除分支：git branch -d dev 合并分支：git merge --no-ff -m &quot;合并信息&quot; dev 合并分支：git rebase dev 暂存任务 暂存当前任务：git stash 取出暂存任务：git stash pop github 建立远程连接：git remote add origin xxxxxxxxxx.git 从远程取分支的更新并与本地指定分支结合：git pull origin remotebranch:localbranch 远程分支的更新与当前分支结合：git pull origin remotebranch 将本地分支上传到远程分支：git push -u origin master 将本地分支强制上传到远程分支：git push -fu origin master（覆盖掉远程分支的所有文件）]]></content>
      <categories>
        <category>git</category>
        <category>github</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
</search>
