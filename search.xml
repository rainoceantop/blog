<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python多线程与多进程]]></title>
    <url>%2Fblog%2F2018%2F05%2F22%2Fpython%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%A4%9A%E8%BF%9B%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[主要列举python使用多线程的方法 python的GIL锁的介绍 python的多进程的方法 python多线程 导入：import threading as th 当前激活数：threading.active_count() 枚举当前激活线程：threading.enumerate() 当前主运行线程：threading.current_thread() 创建队列：q = queue.Queue 创建线程，指定工作函数，并命名thread1 = threading.Thread(target=thread_job, name=&quot;T1&quot;)thread1.start() 传参t = threading.Thread(target=job, args=(data[i], q)) join 主线程调用该线程，并且等到其完成以后才能接着实行。此处join的原理就是依次检验线程池中的线程是否结束，没有结束就阻塞直到线程结束，如果结束则跳转执行下一个线程的join函数thread1.join() Lock锁 在方法开始前，使用lock.acquire取得锁，结束后使用lock.release解除锁，放入同一线程的锁必须是同一把锁才能锁住，否则还是会交替运行 1234567def job1(): global lock lock.acquire() for i in range(10): print(&quot;T1 is running&quot;) time.sleep(.5) lock.release() GIL:全局解释器锁 协同式多任务处理当一项任务比如网络 I/O启动，而在长的或不确定的时间，没有运行任何 Python 代码的需要，一个线程便会让出GIL，从而其他线程可以获取 GIL 而运行 Python。这种礼貌行为称为协同式多任务处理，它允许并发；多个线程同时等待不同事件。两个线程在同一时刻只能有一个执行 Python ，但一旦线程开始连接，它就会放弃 GIL ，这样其他线程就可以运行。这意味着两个线程可以并发等待套接字连接，这是一件好事。在同样的时间内它们可以做更多的工作。 python多进程 导入：import multiprocessing as mp 创建跟线程一样 创建进程锁和线程一样 创建队列：q = mp.Queue() 创建进程池：pool = mp.Pool() # 默认火力全开，指定核数mp.Pool(processes=3) 指定工作：res = pool.map(job, range(100)) # 一次性分配给多个线程工作，第二个参数作为参数传进第一个参数所代表的函数内res = p1.apply_async(job, (2,)) # 一次只能分配给一个线程 创建共享内存： 12v = mp.Value(&quot;i&quot;, 0)a = mp.Array(&quot;i&quot;, [0, 1, 2, 3])]]></content>
      <categories>
        <category>python</category>
        <category>GIL线程锁</category>
        <category>python多线程</category>
        <category>python多进程</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>GIL线程锁</tag>
        <tag>python多线程</tag>
        <tag>python多进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tkinter的使用]]></title>
    <url>%2Fblog%2F2018%2F05%2F22%2Ftkinter%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Tkinter模块(“Tk 接口”)是Python的标准Tk GUI工具包的接口.Tk和Tkinter可以在大多数的Unix平台下使用,同样可以应用在Windows和Macintosh系统里.Tk8.0的后续版本可以实现本地窗口风格,并良好地运行在绝大多数平台中。 注：所有窗口部件都要pack或别的方法使其安装在窗口上面，这里部分省略 tkinter123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318import tkinter as tk# 创建窗口对象window = tk.Tk()# 定义窗口名window.title(&apos;我的第一个窗口&apos;)# 给定窗口长宽，乘号用小写x代替window.geometry(&apos;200x100&apos;)# 定义一个tk的字符串变量var = tk.StringVar()# 创建window对象的标签,textvariable为标签内容，bg背景，font字体和大小，width为15个字符的宽度，height为2个字符的宽度,# wraplength为根据限制长度换行不切割单词, justify为文字显示方式，可为left，right，centera = tk.Label(window, textvariable=var, bg=&apos;yellow&apos;, font=(&apos;Arial&apos;, 12, &apos;bold&apos;), width=15, height=2, wraplength=150, justify=&apos;center&apos;)# 将标签显示上去a.pack()# 创建window对象的按钮,command为点击按钮时要用到的函数b = tk.Button(window, text=&apos;惦记我&apos;, width=15, height=1, command=hit_me)# 定义window窗口的输入框，show可为None，即不处理，如果为密码框可将show赋值*e = tk.Entry(window, show=&apos;*&apos;)# 定义window的文本框t = tk.Text(window, height=3)t.insert(&apos;insert&apos;, string) # 向文本框当前位置插入文本t.insert(&apos;end&apos;, string) # 向文本框末尾插入文本t.insert(&apos;1.1&apos;, string) # 向文本框第一行第一列插入文本t.config(wrap=&apos;word&apos;) # 以单词分隔换行t.config(state=&apos;disabled&apos;) # 禁用文本框t.get(&apos;1.0&apos;, &apos;end&apos;) # 从第一行第零列开始，到最后获取全部内容 t.get(&apos;1.0&apos;, &apos;1.end&apos;) # 获取第一行全部内容t.delete(&apos;1.0&apos;) # 删除第一行第一列的字符t.delete(&apos;1.0&apos;, &apos;1.end&apos;) # 删除第一行t.tag_add(&apos;my_tag&apos;, &apos;1.0&apos;, &apos;1.0 wordend&apos;) # 添加标签t.tag_configure(&apos;my_tag&apos;, background=&apos;yellow&apos;) # 为标签添加颜色t.tag_remove(&apos;my_tag&apos;, &apos;1.1&apos;, &apos;1.3&apos;) # 移除指定范围的tag渲染t.tag_ranges(&apos;my_tag&apos;) # 获取tag的渲染范围t.tag_names() # 不传参数返回所有tag名t.tag_delete(&apos;my_tag&apos;) # 删除tag# 还有图片什么的就不说了# 创建列表部件string = tk.StringVar()string.set((1, 2, &apos;hello&apos;, &apos;你好&apos;))lb = tk.Listbox(window, listvariable=string)lb.insert(&apos;end&apos;, &apos;haha&apos;)lb.pack()# 创建单选按钮，text为显示标签，variable为选中时绑定的变量，value为变量赋值，command为触发方法var = tk.StringVar()def print_selection(): print(&apos;你刚点击了&#123;&#125;选项&apos;.format(var.get()))r1 = tk.Radiobutton(window, text=&apos;A选项&apos;, variable=var, value=&apos;A&apos;, command=print_selection)# 创建复选框，text为显示标签，variable为选中时绑定的变量，on/offvalue为变量赋值，command为触发方法var1 = tk.IntVar()var2 = tk.IntVar()def print_selection(): if var1.get() == 1 and var2.get() == 0: print(&apos;you are right :), I only love python&apos;)c1 = tk.Checkbutton(window, text=&apos;Python&apos;, variable=var1, onvalue=1, offvalue=0, command=print_selection)c2 = tk.Checkbutton(window, text=&apos;Java&apos;, variable=var2, onvalue=1, offvalue=0, command=print_selection) # 创建尺度def print_selection(v): print(v)s = tk.Scale(window, label=&apos;拉我&apos;, # 定义尺度名 from_=5, to=10, # 定义尺度范围 orient=tk.HORIZONTAL, # 定义尺度的摆放方式，水平或垂直 length=200, # 定义尺度的长度，像素单位 showvalue=1, # 是否显示值 tickinterval=1, # 定义显示标签的间隔长度 resolution=0.01, # 定义数字的精确范围 command=print_selection)# 创建数字范围year = tk.StringVar()tk.Spinbox(window, from_=1996, to=2017, textvariable=year).pack() # 创建画布，bg为背景颜色，width/height为像素宽高canvas = tk.Canvas(window, bg=&apos;#FFEFD5&apos;, height=500, width=500)# 创建包含图片位置的对象image_file = tk.PhotoImage(file=&apos;timg.gif&apos;)# 画布创建图片，图片放在10， 10位置，锚点在西北方向，image为指定的存放图片位置的对象image = canvas.create_image(10, 10, anchor=&apos;nw&apos;, image=image_file)x0, y0, x1, y1 = 50, 50, 150, 150# 画布上画线line = canvas.create_line(x0, y0, x1, y1)# 画布上画圆oval = canvas.create_oval(x0, y0, x1, y1, fill=&apos;red&apos;)# 画布上画扇形arc = canvas.create_arc(x0+30, y0+30, x1+30, y1+30, start=0, extent=180, fill=&apos;green&apos;)# 画布上画矩形rect = canvas.create_rectangle(x0, y0, x1, y1, fill=&apos;yellow&apos;)canvas.pack()def move_down(): canvas.move(rect, 0, 2)b = tk.Button(window, text=&apos;move down&apos;, command=move_down).pack()# 获取画布上的线坐标canvas.coords(line)canvas.coords(line, 0, 0, 132, 156, 12, 3) # 修改画布上的线坐标canvas.itemconfigure(line, smooth=True) # 修改属性canvas.itemconfigure(line, splinesteps=5) # 修改属性canvas.delete(line) # 删除线# 画布上创建窗口部件canvas.create_window(320, 60, window=button)def canvas_click(event): x = canvas.canvasx(event.x) # 获取canvas画布当前的长下鼠标的位置 y = canvas.canvasy(event.y) # 获取canvas画布当前的宽下鼠标的位置canvas.bind(&apos;&lt;l&gt;&apos;, canvas_click) # 绑定点击事件# 创建栏目条def do_job(): global count count += 1 print(count)menubar = tk.Menu(window)# 创建栏目项，定义所属栏目条，是否显示分离线filemenu = tk.Menu(menubar, tearoff=0)# 栏目条级联栏目项，为该项取名并显示menubar.add_cascade(label=&apos;file&apos;, menu=filemenu)# 栏目项添加功能项filemenu.add_command(label=&apos;New&apos;, command=do_job)filemenu.add_command(label=&apos;Open&apos;, command=do_job)filemenu.add_command(label=&apos;Save&apos;, command=do_job)# 添加分隔线filemenu.add_separator()filemenu.add_command(label=&apos;Exit&apos;, command=window.quit)# 在后面添加快捷键标识filemenu.entryconfig(&apos;New&apos;, accelerator=&apos;Ctrl + N&apos;)filemenu.entryconfig(&apos;New&apos;, image=logo, compound=&apos;left&apos;) # 添加图片标识filemenu.entryconfig(&apos;New&apos;, state=&apos;disabled&apos;) # 禁用选项filemenu.delete(&apos;New&apos;) # 删除选项# 创建栏目项，定义所属栏目条，是否显示分离线editmenu = tk.Menu(menubar, tearoff=0)# 栏目条级联栏目项，为该项取名并显示menubar.add_cascade(label=&apos;edit&apos;, menu=editmenu)# 栏目项添加功能项editmenu.add_command(label=&apos;Cut&apos;, command=do_job)editmenu.add_command(label=&apos;Copy&apos;, command=do_job)editmenu.add_command(label=&apos;Paste&apos;, command=do_job)# 创建下级栏目项submenu = tk.Menu(editmenu, tearoff=0)editmenu.add_cascade(label=&apos;import&apos;, menu=submenu, underline=0)submenu.add_command(label=&apos;python file&apos;, command=do_job)# 给窗口装上栏目条window.config(menu=menubar)# 定义框frm = tk.Frame(window)frm.pack()# 定义框中的左框frm_left = tk.Frame(frm)# 定义框中的右框frm_right = tk.Frame(frm)frm_left.pack(side=&apos;left&apos;)frm_right.pack(side=&apos;right&apos;)tk.Label(window, text=&apos;我在窗口上&apos;).pack()tk.Label(frm_left, text=&apos;我在左框上&apos;).pack()tk.Label(frm_right, text=&apos;我在右框上&apos;).pack()# 弹出信息from tkinter import messageboxdef on_hit(): # 弹出信息提示框 messagebox.showinfo(title=&apos;Hi&apos;, message=&apos;哈哈哈&apos;) # 弹出警告 messagebox.showwarning(title=&apos;Warning&apos;, message=&apos;got some warning&apos;) # 错误提醒 messagebox.showerror(title=&apos;Error&apos;, message=&apos;got some error&apos;) # return True/False/None messagebox.askyesnocancel(title=&apos;check&apos;, message=&apos;你确定？&apos;) # return yes/no messagebox.askquestion(title=&apos;ask&apos;, message=&apos;我问一下&apos;) # return True/False messagebox.askyesno(title=&apos;ask&apos;, message=&apos;我问一下&apos;) messagebox.askokcancel(title=&apos;ask&apos;, message=&apos;我问一下&apos;) messagebox.askretrycancel(title=&apos;ask&apos;, message=&apos;是否重试一下&apos;)tk.Button(window, text=&apos;点我&apos;, command=on_hit).pack()# 部件放置方法pack(side=&apos;top&apos;, fill=X, expand=True) # side可设置为top, bottom, left, right, fill可设置为X,Y,BOTH, expand是否拓展全局for widget in root.pack_slaves(): # 设置所有pack的属性 widget.pack_configure(fill=BOTH, expand=True)grid(row=5, column=3, padx=10, pady=10) # row/column为第几行/列，padx/pady或ipadx/ipady为x/y轴方向的外部/内部间距place(x=200, y=100, anchor=&apos;nw&apos;) # 放置在具体像素点的位置，anchor可定义可不定义place(relx=0.5, rely=0.5, anchor=&apos;center&apos;) # 拉升时相对x/y轴放置place(relwidth=0.5, relheight=0.3) # 相对于当前窗口大小所设置的大小place(relx=0.5, x=200, rely=0.5, y=100, anchor=&apos;center&apos;) # 绝对和相对相结合# 修改部件的所有参数部件名.config()# 创建基于另一个窗口的窗口window = tk.Toplevel(root)window.title(&apos;window&apos;)window.lift(root) # 窗口显示在root窗口上面window.lower(root) # 窗口显示在root窗口下面window.state(&apos;zoomed&apos;) # 窗口最大化window.state(&apos;withdrawn&apos;) # 关闭窗口window.state(&apos;iconic&apos;) # 最小化窗口window.state(&apos;normal&apos;) # 将窗口恢复正常（有时需要运行两次才能恢复）window.iconify() # 最小化窗口window.deiconify() # 取消最小化窗口window.geometry(&apos;640x480+50+100&apos;) # 前面乘法为窗口的长和宽，后面加法为屏幕的左边距和上边距window.maxsize(640, 480) # 限制窗口的最大长宽window.minsize(200, 200) # 限制窗口的最小长宽window.resizable(True, True) # 窗口是否可自由拉升，第一个x限制左右拉升，第二个y限制上下拉升window.destroy() # 彻底关闭窗口root.mainloop()# 创建基于root窗口的水平方向面板框panedwindow = ttk.Panedwindow(root, orient=&apos;horizontal&apos;)# fill=&apos;both&apos;让这个面板框填满窗口,expand=True表示当窗口拉升时也一样填满窗口panedwindow.pack(fill=&apos;both&apos;, expand=True)frame1 = ttk.Frame(panedwindow, width=100, height=300, relief=&apos;sunken&apos;)frame2 = ttk.Frame(panedwindow, width=400, height=300, relief=&apos;sunken&apos;)panedwindow.add(frame1, weight=1) # 当窗口拉升时，宽也随着拉升1单位panedwindow.add(frame2, weight=4) # 当窗口拉升时，宽也随着拉升4单位frame3 = ttk.Frame(panedwindow, width=50, height=300, relief=&apos;sunken&apos;)panedwindow.insert(1, frame3) # 可调节大小，但窗口拉升时大小不变panedwindow.forget(1) # 删除掉索引1的面板框# 创建样式style = ttk.Style()print(style.theme_names()) # 获取主题列表print(style.theme_use()) # 获取当前使用的主题button = ttk.Button(root, text=&apos;button&apos;)button2 = ttk.Button(root, text=&apos;button2&apos;)button.pack()button2.pack()style.theme_use(&apos;xpnative&apos;) # 更换主题print(button.winfo_class()) # 获取配置样式时该部件的别名style.configure(button.winfo_class(), foreground=&apos;blue&apos;, background=&apos;yellow&apos;) # 配置全局样式style.configure(&apos;Alarm.TButton&apos;, foreground=&apos;orange&apos;, font=(&apos;Arial&apos;, 24, &apos;bold&apos;)) # 配置局部样式style.map(&apos;Alarm.TButton&apos;, foreground=[(&apos;pressed&apos;, &apos;pink&apos;), (&apos;disabled&apos;, &apos;grey&apos;)]) # 配合map进行更多的配置button2.config(style=&apos;Alarm.TButton&apos;) # 使用局部样式print(style.layout(button.winfo_class())) # 获取该部件的布局print(style.element_options(&apos;Button.padding&apos;)) # 获取元素选项print(style.lookup(&apos;TButton&apos;, &apos;foreground&apos;)) # 获取该属性当前值# 设置窗口行列随着拉升root.rowconfigure(0, weight=1) # 1单位拉升root.rowconfigure(1, weight=3) # 3单位拉升# 打开文件from tkinter import filedialogfilename = filedialog.askopenfile() # 请求弹出文件选择框,还有保存啥的就不举例了print(filename.name) # 打印文件位置# 颜色选择器from tkinter import colorchoosercolor = colorchooser.askcolor(initialcolor=&apos;#FFFFFF&apos;)# 键盘按键绑定监听def key_press(event): print(&apos;type: &#123;&#125;&apos;.format(event.type)) print(&apos;widget: &#123;&#125;&apos;.format(event.widget)) print(&apos;char: &#123;&#125;&apos;.format(event.char)) # 获取所按字符 print(&apos;keysym: &#123;&#125;&apos;.format(event.keysym)) print(&apos;keycode: &#123;&#125;&apos;.format(event.keycode))root.bind(&apos;&lt;KeyPress&gt;&apos;, key_press) # 监听键盘按键def shortcut(action): print(action)root.bind(&apos;&lt;Control-c&gt;&apos;, lambda e: shortcut(&apos;Copy&apos;)) # 监听复制按键root.bind(&apos;&lt;Control-v&gt;&apos;, lambda e: shortcut(&apos;Paste&apos;)) # 监听粘贴按键# 鼠标按键绑定监听canvas = tk.Canvas(root, width=640, height=480, background=&apos;white&apos;)canvas.pack()def mouse_press(event): print(&apos;type: &#123;&#125;&apos;.format(event.type)) print(&apos;widget: &#123;&#125;&apos;.format(event.type)) print(&apos;num: &#123;&#125;&apos;.format(event.type)) print(&apos;x: &#123;&#125;&apos;.format(event.x)) # 获取鼠标的x位置 print(&apos;y: &#123;&#125;&apos;.format(event.y)) # 获取鼠标的y位置canvas.bind(&apos;&lt;ButtonPress&gt;&apos;, mouse_press) # 鼠标单击事件bind(&apos;&lt;l&gt;&apos;, lambda e: print(&apos;&lt;l&gt;&apos;)) # 绑定鼠标左键unbind(&apos;&lt;l&gt;&apos;) # 取消绑定鼠标左键def mouse_press(event): global prev prev = eventcanvas.bind(&apos;&lt;ButtonPress&gt;&apos;, mouse_press)def draw(event): global prev canvas.create_line(prev.x, prev.y, event.x, event.y, fill=&apos;orange&apos;) prev = eventcanvas.bind(&apos;&lt;B1-Motion&gt;&apos;, draw) # 监听鼠标长按事件# 显示窗口window.mainloop() ttk123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105# ttk里设置前景颜色和背景颜色foreground=&apos;blue&apos;, background=&apos;yellow&apos;# 设置图片（包含label，button等等部件都可以，这里用label举例）logo = tk.PhotoImage(file=&apos;timg.gif&apos;)small_logo = logo.subsample(10, 10) # 按倍数缩小图片label.config(image=self.logo)-----------------------------self.label.img = self.logoself.label.config(image=self.label.img)# 将标签的背景图片和文字结合label.config(compound=&apos;center&apos;)label.config(compound=&apos;left&apos;)label.config(compound=&apos;right&apos;)# 获取部件的信息button = ttk.Button(window, text=&apos;click me&apos;)print(button[&apos;text&apos;])# 修改部件信息button[&apos;text&apos;] = &apos;you click me&apos;button.config(text=&apos;push me&apos;)# 获取部件可用配置print(button.config())# 获取tkinter内部的身份认证识别代号print(str(button))# 按钮/文本的各种内置方法button.invoke() # 调用按钮的方法，如果该按钮绑定的方法没有返回值，会返回Nonebutton.state([&apos;disabled&apos;]) # 禁用该按钮button.instate([disabled]) # 获取按钮的状态，返回True，Falsebutton.state([&apos;!disabled&apos;]) # 解除按钮禁用entry.state([&apos;readonly&apos;]) # readonly只能用于文本# 创建下拉列表month = tk.StringVar() # 该变量可用于获取/修改当前选中的值combobox = ttk.Combobox(window, textvariable=month, values=([x for x in range(1996, 2017)]))combobox.pack()print(month.get())# 创建进度条progressbar = ttk.Progressbar(window, orient=&apos;horizontal&apos;, length=200)progressbar.pack()progressbar.config(mode=&apos;indeterminate&apos;)# 进度条不定时（来回滚动）progressbar.start() # 进度条开始progressbar.stop() # 进度条结束progressbar.step(5) # 进度条跳到这里progressbar.config(mode=&apos;determinate&apos;, maximum=11.0, value=4.2) # 进度条向最大值100%前进# 定义框frame = ttk.Frame(window)frame.pack()frame.config(height=100, width=200) # 定义frame宽高# 共有六种frame显示浮雕# flat,raised,sunken,solid,ridge,grooveframe.config(relief=&apos;raised&apos;)ttk.Button(frame, text=&apos;click me&apos;).grid() # 在frame里添加部件frame.config(padding=(40, 15)) # 定义frame内边距ttk.LabelFrame(window, height=100, width=200, text=&apos;label frame&apos;).pack() # 创建带有标签的frame# 创建树图treeview = ttk.Treeview(root)treeview.pack()# 向树图插入节点，参数1为父母节点，参数2为索引，参数3为节点id，参数4为节点名treeview.insert(&apos;&apos;, &apos;0&apos;, &apos;item1&apos;, text=&apos;First Item&apos;)treeview.insert(&apos;&apos;, &apos;1&apos;, &apos;item2&apos;, text=&apos;Second Item&apos;)treeview.insert(&apos;&apos;, &apos;end&apos;, &apos;item3&apos;, text=&apos;Third Item&apos;)logo = tk.PhotoImage(file=&apos;timg.gif&apos;).subsample(10, 15)treeview.insert(&apos;item3&apos;, &apos;0&apos;, &apos;subitem&apos;, text=&apos;OMG&apos;, image=logo)treeview.config(height=5) # 设置树图的属性值treeview.move(&apos;item3&apos;, &apos;item1&apos;, &apos;0&apos;) # 移动节点，参数1为移动的节点，参数2为移动到哪个父母节点下，参数3为新的索引值treeview.item(&apos;item1&apos;, open=True) # 设置该节点自动打开print(treeview.item(&apos;item1&apos;, &apos;open&apos;)) # 获取该节点是否打开,打开返回1，闭合返回0treeview.detach(&apos;item2&apos;) # 分离隐藏该节点，但没有删除，可以移动到别的节点下treeview.delete(&apos;item2&apos;) # 完全删除节点treeview.config(columns=(&apos;duck&apos;, &apos;bird&apos;)) # 定义列treeview.column(&apos;duck&apos;, width=50, anchor=&apos;center&apos;) # 按名称设置列的属性值treeview.column(&apos;#0&apos;, width=300) # 按索引设置列的属性值treeview.heading(&apos;duck&apos;, text=&apos;duck&apos;) # 设置列名treeview.set(&apos;subitem&apos;, &apos;duck&apos;, &apos;gagaga&apos;) # 在该列下填内容，参数1指定节点，参数2指定列，参数3内容treeview.item(&apos;subitem&apos;, tags=(&apos;bg&apos;, &apos;bg2&apos;)) # 为节点添加标签treeview.tag_configure(&apos;bg&apos;, background=&apos;yellow&apos;) # 设置标签属性def callback(event): print(treeview.selection())treeview.bind(&apos;&lt;&lt;TreeviewSelect&gt;&gt;&apos;, callback) # 绑定事件，当树图被点击，运行函数treeview.config(selectmode=&apos;browse&apos;) # 限制每次最多可选一个节点treeview.config(selectmode=&apos;none&apos;) # 限制节点不可选treeview.selection_add(&apos;item1&apos;, &apos;subitem&apos;) # 自动选择节点treeview.selection_remove(&apos;item1&apos;) # 取消选择的节点treeview.selection_toggle(&apos;item3&apos;, &apos;subitem&apos;) # 相反方向选择或取消节点# 创建滚动条text = tk.Text(root, width=40, height=10, wrap=&apos;word&apos;)text.grid(row=0, column=0)scrollbar = ttk.Scrollbar(root, orient=&apos;vertical&apos;, command=text.yview) # 垂直方向创建滚动条scrollbar.grid(row=0, column=1, sticky=&apos;ns&apos;) # 安置滚动条的位置text.config(yscrollcommand=scrollbar.set) # 设置滚动条随长度进行处理 简单类实现1234567891011121314151617181920212223242526import tkinter as tkfrom tkinter import ttkclass HelloApp: def __init__(self, master): self.label = ttk.Label(master, text=&apos;hello, tkinter&apos;) self.label.grid(row=0, column=0, columnspan=2) ttk.Button(master, text=&apos;Texas&apos;, command=self.texas_hello).grid(row=1, column=0) ttk.Button(master, text=&apos;Hawaii&apos;, command=self.hawaii_hello).grid(row=1, column=1) def texas_hello(self): self.label.config(text=&apos;howdy,tkinter&apos;) def hawaii_hello(self): self.label.config(text=&apos;aloha,tkinter&apos;)if __name__ == &apos;__main__&apos;: window = tk.Tk() app = HelloApp(window) window.mainloop()]]></content>
      <categories>
        <category>python</category>
        <category>tkinter</category>
        <category>ttk</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>tkinter</tag>
        <tag>ttk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux基本指令]]></title>
    <url>%2Fblog%2F2018%2F05%2F22%2Flinux%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Linux是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU的操作系统。它能运行主要的UNIX工具软件、应用程序和网络协议。它支持32位和64位硬件。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。严格来讲，Linux这个词本身只表示Linux内核，但实际上人们已经习惯了用Linux来形容整个基于Linux内核，并且使用GNU 工程各种工具和数据库的操作系统。开发者：Linus Torvalds（同时也是git的开发者，他是神↓） 目录操作 进入目录：cd mulu/mulu2 返回目录：cd ../.. 返回最上层目录：cd - 返回home:cd ~ 绝对路径进入目录：cd /home/jesse/Documents/folder 文件操作 创建文件：touch file1.txt file2 file3 创建文件夹：mkdir folder3 删除文件夹：rmdir folder3(删除空文件夹) 删除文件/文件夹： 123456rm file1rm -r folder1/(递归逐个删除)rm -i file1 file2 file3 file4(逐个提示是否删除)rm -I file1 file2 file3 file4(大于三个文件时提示是否删除)rm *(清空该目录下所有文件)rm /(清空系统所有文件) 复制文件： 1234567cp file1 filecopy(如果存在会覆盖)cp -i file1 filecopy(如果存在会提示)cp file1 folder/(复制到文件夹folder中，/识别文件夹)cp -R folder/ folder2/(-R代表递归，逐个将folder的文件复制到folder2中)cp file* folder2/(将所有file开头的文件复制到folder2目录下)cp *file folder2/(将所有file结尾的文件复制到folder2目录下)cp file1 file2 file3 folder2/(将前面所有的东西复制到最后所指的目录) 剪切：mv file1 folder/ 查看当前目录下的文件列表：ls 查看当前目录下的文件列表的详细信息：ls -l 或者 ls -lh(适合人类看的) 查看当前目录下的所有文件列表：ls -a 查看ls的所有功能：ls --help nano编辑文件(功能命令^代表ctrl键)：nano t.py(不存在文件的话会自动创建文件) cat编辑文件： 1234cat t.py(显示文件内容)cat t.py &gt; t1.py(将t.py的内容复制到t1.py中)cat t.py t1.py &gt; t2.py(将t.py t1.py的内容复制到t2.py中)cat t3.py &gt;&gt; t2.py(将t3.py的内容加到t2.ty的后面) 运行python3文件：python3 t.py 权限操作 权限：第一个代表类型，第2-4代表user，第5-7代表group，第8-10代表其他的权限drwxr-xr-x：d代表文件夹类型，r代表可读，w代表可写，x代表可执行(执行命令：./t1.py)-rw-r--r--：第一个-代表文件类型 修改权限： 1234567chmod u+r t1.py(为user用户t1.py增加可读权限)chmod u+rwx t1.py(为user用户t1.py增加可读可写可执行权限)chmod u-r t1.py(为user用户t1.py减去可读权限)chmod g+r t1.py(为group用户t1.py增加可读权限)chmod o+r t1.py(为others用户t1.py增加可读权限)chmod a+r t1.py(为全部用户t1.py增加可读权限)chmod ug+r t1.py(为user,group用户t1.py增加可读权限) 通过权限运行的文件要在文件最开头一行添加解释器： #!/usr/bin/python3 SSH链接操作 下载linux SSH终端：sudo apt-get install openssh-server 获取ip地址：ifconfig(如果提示没安装一些东西：sudo apt install net-tools) 用mac控制linux：ssh jesse@192.168.0.108 用windows控制：下载PuTTY 手机控制：下载ssh应用 控制后图形界面显示： 使用外网 Teamviewer 使用局域网 VNC(sudo apt-get install x11vnc) mac将文件推送到linux运行：ssh jesse@192.168.0.108 python3 &lt; t1.py(将t1.py推送到linux上运行) 将文件复制到linux上：scp {a,b}.py jesse@192.168.0.108:~/Desktop/ 从linux云端保存到本地：scp jesse@192.168.0.108:~/Desktop/b.py c.py 控制云端弹出窗口：ssh jesse@192.168.0.108 &quot;export DISPLAY:0; firefox&quot; linux创建共享文件夹： 右键文件夹点击share。。。啥的 设置远程共享的密码：sudo smbpasswd -a jesse 其他 清空命令行：clear 下载软件：sudo apt-get install xxxxx]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib的使用]]></title>
    <url>%2Fblog%2F2018%2F05%2F22%2Fmatplotlib%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Matplotlib 是一个 Python 的 2D绘图库，它以各种硬拷贝格式和跨平台的交互式环境生成出版质量级别的图形 。通过 Matplotlib，开发者可以仅需要几行代码，便可以生成绘图，直方图，功率谱，条形图，错误图，散点图等。开发者：John D. Hunter matplotlib 安装：pip install matplotlib 画图 导入 import matplotlib.pyplot as plt画线 plt.plot(x, y) plt.plot([1, 2, 3], [5, 7, 4], label=&#39;first graph&#39;)画日期线 plt.plot(x, y)画柱状图 plt.bar(x, y, label=&#39;first bar&#39;, color=&#39;#FFE4C4&#39;)画直方图(统计范围内符合的数量) plt.hist(x, y, histtype=&#39;bar&#39;, label=&#39;first histogram&#39;, rwidth=0.8)画分散图 plt.scatter(x, y, label=&#39;first scatter&#39;, marker=&#39;*&#39;, s=100)画堆栈图1234567891011days = [1, 2, 3, 4, 5, 6, 7]sleeping = [8, 8, 8, 8, 8, 10, 10]eating = [2, 2, 2, 2, 2, 2, 2]working = [8, 8, 8, 8, 8, 2, 2]playing = [6, 6, 6, 6, 6, 10, 10]#python这个库不带堆栈图标记，自己创建唯标记plt.plot([], [], color=&apos;#7AC5CD&apos;, label=&apos;Sleeping&apos;, linewidth=5)plt.plot([], [], color=&apos;#FAEBD7&apos;, label=&apos;Eating&apos;, linewidth=5)plt.plot([], [], color=&apos;#9AFF9A&apos;, label=&apos;Working&apos;, linewidth=5)plt.plot([], [], color=&apos;#FFF68F&apos;, label=&apos;Playing&apos;, linewidth=5)plt.stackplot(days, sleeping, eating, working, playing, colors=[&apos;#7AC5CD&apos;, &apos;#FAEBD7&apos;, &apos;#9AFF9A&apos;, &apos;#FFF68F&apos;]) 画扇形图1234slices = [8, 2, 8, 6]activities = [&apos;sleeping&apos;, &apos;eating&apos;, &apos;working&apos;, &apos;playing&apos;]colors = [&apos;#7AC5CD&apos;, &apos;#FAEBD7&apos;, &apos;#9AFF9A&apos;, &apos;#FFF68F&apos;]plt.pie(slices, labels=activities, colors=colors, startangle=90, shadow=True, explode=[0, 0.1, 0, 0], autopct=&apos;%1.1f%%&apos;) 颜色作为参数color传进画图函数里x-轴命名 plt.xlabel(&#39;quality&#39;)y-轴命名 plt.ylabel(&#39;amount&#39;)图表名称 plt.title(&#39;quality-amount statistics\ncheck it out&#39;)显示标记 plt.legend()显示 plt.show() 读取文件 读取csv文件12345678910import csvx = []y = []with open(&apos;example.txt&apos;, &apos;r&apos;) as csvfile: plots = csv.reader(csvfile, delimiter=&apos;,&apos;) for row in plots: x.append(int(row[0])) y.append(int(row[1]))plt.plot(x, y, label=&apos;loaded from file!&apos;) 使用numpy读取txt文件123# 正常情况下将返回一个二维矩阵，设置unpack=True后返回各列x, y = np.loadtxt(&apos;example.txt&apos;, delimiter=&apos;,&apos;, unpack=True)plt.plot(x, y, label=&apos;loaded from file!&apos;) 自定义 设置图内标签123ax1.legend()leg = legend(loc=9, ncol=2, prop=&#123;&apos;size&apos;:11&#125;) # loc定义位置参数，ncol表示显示列数，prop传递各种参数leg.get_frame().set_alpha(0.4) # 设置透明度 标签旋转1234#需要将图形变成网格并赋予一个变量的时候才能使用ax1 = plt.subplot2grid((3, 2), (2, 0), colspan=2)for label in ax1.xaxis.get_ticklabels(): label.set_rotation(90) 显示网格：ax1.grid(True, color=&#39;green&#39;, linestyle=&#39;-&#39;, linewidth=&#39;2&#39;)调整图形位置：plt.subplots_adjust(bottom=0.45)改变x/y轴标签颜色：ax1.xaxis.label.set_color(&#39;c&#39;) ax1.yaxis.label.set_color(&#39;r&#39;)设置x/y轴坐标间隔：ax1.set_xticks([]) ax1.xaxis.set_ticks([]) ax1.set_yticks([]) ax1.yaxis.set_ticks([])填充颜色：ax1.fill_between(thetime, price, price[0], facecolor=&quot;g&quot;, alpha=0.3)操作坐标轴：ax1.spines[&#39;left&#39;].set_color(&#39;g&#39;) ax1.spines[&#39;right&#39;].set_visible(False) ax1.spines[&#39;left&#39;].set_linewidth(5)修改坐标轴时间格式：ax1.xaxis.set_major_formatter(mdates.DateFormatter(&quot;%Y-%m-%d&quot;))修改坐标轴间隔：ax1.xaxis.set_major_locator(mticker.MaxNLocator(5))参数操作x/y轴：ax1.tick_params(axis=&#39;x&#39;, colors=&#39;g&#39;)操作水平/垂直线：ax1.axhline(price[0], color=&#39;k&#39;, linewidth=5) ax1.axvline(thetime[0], color=&#39;k&#39;, linewidth=5)限制坐标轴：ax2v.set_ylim(0, 5*max(y)) #按原来的y轴的1/5缩放共享坐标轴： ax2 = plt.subplot(212, sharex=ax1)使用样式1234from matplotlib import stylestyle.use(&apos;ggplot&apos;)style.use(&apos;fivethirtyeight&apos;)print(plt.style.available) 嵌入文字12font_dict = &#123;&apos;family&apos;: &apos;serif&apos;, &apos;color&apos;: &apos;darkred&apos;, &apos;size&apos;: 20&#125;ax1.text(float(xs[5]), float(ys[5]), &apos;555&apos;, fontdict=font_dict) (标签的类型一定要相同) 获取文件位置：print(plt.__file__) 同步更新数据 示例代码123456789101112131415161718192021222324252627282930313233from matplotlib import animationfig = plt.figure()ax1 = fig.add_subplot(1, 1, 1)# 写一个获取数据的函数def animate(i): graph_data = open(&apos;example.txt&apos;, &apos;r&apos;).read() lines = graph_data.split(&apos;\n&apos;) xs = [] ys = [] for line in lines: if len(line) &gt; 1: x, y = line.split(&apos;,&apos;) xs.append(x) ys.append(y) ax1.clear() ax1.plot([float(a) for a in xs], [float(b) for b in ys])# 每过一秒更新一次ani = animation.FuncAnimation(fig, animate, interval=1000)plt.show()箭头指向(x，y轴的标签类型要一致)：ax1.annotate(&apos;bad news&apos;, (float(xs[6]), float(ys[6])), xytext=(0.8, 0.9), textcoords=&apos;axes fraction&apos;, arrowprops=dict(facecolor=&apos;grey&apos;, color=&apos;grey&apos;)) 显示最后一个值：bbox_props = dict(boxstyle=&apos;round&apos;, fc=&apos;w&apos;, ec=&apos;k&apos;, lw=1)ax1.annotate(ys[-1], (float(xs[-1]), float(ys[-1])), xytext=(float(xs[-1]), float(ys[-1])), bbox=bbox_props) 分布式格局(使用时添加的标签，标题等要对应在每个图形的上/下面) 创建网格 12345ax1 = fig.add_subplot(221) # 两行两列选第一个ax2 = fig.add_subplot(222, sharex=ax1) # 两行两列选第二个，共享ax1的x坐标轴ax2v = ax2.twinx() # 共用x坐标轴ax3 = fig.add_subplot(212) # 两行一列选第二个plt.subplot2grid((3, 2), (2, 0), colspan=2).plot([0, 1, 2, 3], [10, 20, 30, 15]) 其他 3D图形123456789101112131415161718192021import matplotlib.pyplot as pltfrom mpl_toolkits.mplot3d import Axes3Dimport numpy as np# 设置三维坐标fig = plt.figure()ax = Axes3D(fig)# 生成数据x = np.linspace(-5, 5, 200)y = np.linspace(-5, 5, 200)X, Y = np.meshgrid(x, y) # XY平面的网格数据Z = (1 - X / 2 + X ** 7 + Y ** 5) * np.exp(-X ** 2 - Y ** 2)# 画3d图ax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap=plt.cm.jet)# ax.plot_surface(X,Y,z,rstride=1,cstride=1,cmap=plt.get_cmap(&apos;rainbow&apos;))# 等高线图ax.contourf(X, Y, Z, zdir=&apos;z&apos;, offset=-2, cmap=&apos;rainbow&apos;) # zdir= x/y/x 轴的等高线 offset=等高线的位置plt.show() 正确的matplotlib时间格式： ① 数字类型：20171218 1.用strpdate2num创建转换器：converter = mdates.strpdate2num(&quot;%Y%m%d&quot;) 2.将数组里面的所有值用该转换器转换重新赋值：x = [converter(i) for i in x] 3.用plot_date显示 ② 时间戳类型： 1.用np创建转换器：converter = np.vectorize(datetime.datetime.fromtimestamp) 2.转换x：x = converter(x) 保存图片：fig.savefig(&#39;test.png&#39;, facecolor=fig.get_facecolor())]]></content>
      <categories>
        <category>python</category>
        <category>matplotlib</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pandas的使用]]></title>
    <url>%2Fblog%2F2018%2F05%2F22%2Fpandas%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Pandas是python的一个数据分析包，最初由就职于AQR Capital Management的Wes McKinney于2008年4月开发，并于2009年底开源出来，目前由专注于Python数据包开发的PyData开发team继续开发和维护，属于PyData项目的一部分。Pandas最初被作为金融数据分析工具而开发出来，因此，pandas为时间序列分析提供了很好的支持。 Pandas的名称来自于面板数据（panel data）和python数据分析（data analysis）。panel data是经济学中关于多维数据集的一个术语，在Pandas中也提供了panel的数据类型。开发者：Wes McKinney 创建序列 1s = pd.Series([1, 3, 6, np.nan, 44, 1]) # 打印的时候会显示下标索引，默认类型float64或float32 创建日期范围数组 12dates = pd.date_range(&apos;20171106&apos;, periods=7) # 7天的日期数组pd.Timestamp(&apos;20171106&apos;) # 创建单个时间 创建数据表格及表格操作 123456789# index为行的索引，column为列的索引，如不指定，行和列默认0开始索引df = pd.DataFrame(np.random.randn(7, 4), index=dates, columns=[&apos;r1&apos;, &apos;r2&apos;, &apos;r3&apos;, &apos;r4&apos;]) df2 = pd.DataFrame(&#123; &apos;A&apos;: 1., &apos;B&apos;: pd.Timestamp(&apos;20171106&apos;), &apos;C&apos;: 3, &apos;D&apos;: pd.Categorical([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]), &apos;E&apos;: &apos;food&apos;&#125;) 获取表格每一列的类型：print(df2.dtypes) 获取每一行的索引：print(df.index) 获取每一列的索引：print(df.columns) 获取表格数据：print(df.values) 将表格行列倒置：print(df.T) 计算表格中的数据：df.describe() 对行的索引排序：df.sort_index(axis=1, ascending=False) # ascending=False时表示倒序 对列的索引排序：df.sort_index(axis=0, ascending=False) # ascending=False时表示倒序 对列的值排序：df.sort_values(by=&apos;r4&apos;) 获取列：df[&apos;r3&apos;] 或者 df.r3 切片获取行：df[0:1] 或者 df[dates[0]:dates[1]] # 根据标签索引 select by label 具体索引获取行：df.loc[dates[0]] 具体索引筛选行和列：df.loc[:, [&apos;r3&apos;, &apos;r4&apos;]] # 根据index索引 select by index 根据索引下标获取数据：df.iloc[1:3, 1:3] df.iloc[[1, 3, 5], 1:3] # 混合索引 select by ix 用标签和index混合筛选数据：df.ix[1:3, [&apos;r3&apos;, &apos;r4&apos;]] # 根据boolean索引 boolean indexing 用判断的方式进行筛选：df[df.r3 &gt; 1] 修改表格数据 1234df.iloc[2, 2] = 11df.loc[dates[0], &apos;r3&apos;] = 11df.r1[df.r1 &gt; 1] = 0df[&apos;r5&apos;] = np.nan #添加列 处理表格数据 # 当how等于any的时候，只要包含一个nan的，就删除，如果改为all，则需要行内所有值都为nan的时候才删除 删除包含nan的表格的行：df.dropna(axis=0, how=&apos;any&apos;) # how={&apos;all&apos;, &apos;any&apos;} 删除包含nan的表格的列：df.dropna(axis=1, how=&apos;any&apos;) 填充包含nan的表格的数据：df.fillna(value=0) 判断表格的数据是否为nan：df.isnull() 判断表格至少存在一个nan丢失数据：np.any(df.isnull()) 合并表格 123456789101112131415161718df1 = pd.DataFrame(np.ones((3, 4)) * 0, columns=[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;])df2 = pd.DataFrame(np.ones((3, 4)) * 1, columns=[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;])df3 = pd.DataFrame(np.ones((3, 4)) * 2, columns=[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;])# ingnore_index=True表示忽略原来的索引，用数字有序的索引替代同列栏目向下合并：pd.concat([df1, df2, df3], axis=0, ignore_index=True)df1.append([df2, df3], ignore_index=True)同行栏目向右合并：pd.concat([df1, df2, df3], axis=1, ignore_index=True)# join,[&apos;inner&apos;,&apos;outer&apos;]裁剪掉不同行/列后合并：pd.concat([df1, df2, df3], join=&apos;inner&apos;, ignore_index=True)# join_axes根据某个表的行索引进行合并（没有该索引下表的其他表合并后用NaN表示）：pd.concat([df1, df2, df3], join_axes=[df1.index], axis=1, ignore_index=True)# merge高级合并根据column进行合并：pd.merge(df1, df2, on=&apos;key&apos;, suffixes=[&apos;_left&apos;, &apos;_right&apos;], indicator=True) # 显示合并方式，将true换为一个字符串，可为该列命名，suffixes可为相同名称的列加后缀名多个column进行合并：pd.merge(df1, df2, on=[&apos;key&apos;, &apos;key1&apos;], how=&apos;inner&apos;) # how默认为inner，共有四种选择【&apos;inner&apos;,&apos;outer&apos;,&apos;left&apos;,&apos;right&apos;】# left_index 和 right_index默认为none，设置为true之后将改变合并方式，从根据column合并换为行标签合并根据行标签进行合并：pd.merge(df1, df2, left_index=True, right_index=True, indicator=True) 生成图表 12345import matplotlib.pyplot as pltdata = pd.DataFrame(np.random.randn(1000, 4), columns=[&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;])data = data.cumsum()data.plot()data.plot.scatter(x=&apos;A&apos;, y=&apos;B&apos;) 其他 12data = pd.read_csv(&apos;test.csv&apos;) #读取csv文件data.to_pickle(&apos;test.pkl&apos;) #存储文件]]></content>
      <categories>
        <category>python</category>
        <category>pandas</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[numpy的使用]]></title>
    <url>%2Fblog%2F2018%2F05%2F22%2Fnumpy%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[NumPy 是一个 Python 包。 它代表 “Numeric Python”。 它是一个由多维数组对象和用于处理数组的例程集合组成的库。Numeric，即 NumPy 的前身，是由 Jim Hugunin 开发的。 也开发了另一个包 Numarray ，它拥有一些额外的功能。 2005年，Travis Oliphant 通过将 Numarray 的功能集成到 Numeric 包中来创建 NumPy 包。 这个开源项目有很多贡献者。 创建数组 b = np.array([]) 将list a转成numpy数组 array = np.array(a) 定义numpy数组类型（位数越小，所占用的空间越小） array = np.array([[1, 2, 3], [4, 5, 6]], dtype=np.int64) 将numpy数组转成list a = array.tolist() 创建全部为0的数组 array = np.zeros((3, 4)) # (3, 4)定义三行四列 创建全部为1的数组 array = np.ones((3, 4), dtype=np.int16) # (3, 4)定义三行四列 创建全部为空的数组 array = np.empty((3, 5)) 创建一个有序的数组 array = np.arange(10, 20, 2) # 像range，从10到19，step = 2 创建一个有序的数组，并且定义形状 array = np.arange(12).reshape((3, 4)) 创建一个有规律的分段的数组 array = np.linspace(0, 10, 6).reshape((2, 3)) 获取数组的维度 print(array.ndim) 获取数组的形状（行列数）print(array.shape) 获取数组的元素总和 print(array.size) 获取数组的类型 print(array.dtype) 数组的运算 a = np.array([10, 20, 30, 40]) b = np.arange(4) 加法运算：c = a + b 减法运算：c = a - b 乘法运算：c = a * b 除法运算：c = a / b sin计算：np.sin(a) cos计算：np.cos(a) tan计算：np.tan(a) 数组的所有元素的和：a.sum() 或者 np.sum(a) 求中位数：np.median(a) 数组的所有元素的平均值：a.mean() 或者 np.mean(a) 数组里的最小值：a.min() 或者 np.min(a) 最小值的索引：a.argmin() 或者 np.argmin(a) 数组里的最大值：a.max() 或者 np.max(a) 最大值的索引：a.argmax() 或者 np.argmax(a) 行中的运算 总和 a.sum(axis=1) 或者 np.sum(a, axis=1) 最小值 a.min(axis=1) 或者 np.min(a, axis=1) 最小值的索引：a.argmin(axis=1) 或者 np.argmin(a, axis=1) 最大值 a.max(axis=1) 或者 np.max(a, axis=1) 最大值的索引：a.argmax(axis=1) 或者 np.argmax(a, axis=1) 列中的运算 总和 a.sum(axis=0) 或者 np.sum(a, axis=0) 最小值 a.min(axis=0) 或者 np.min(a, axis=0) 最小值的索引：a.argmin(axis=0) 或者 np.argmin(a, axis=0) 最大值 a.max(axis=0) 或者 np.max(a, axis=0) 最大值的索引：a.argmax(axis=0) 或者 np.argmax(a, axis=0) 判断数组的值 print(array &lt; 5) print(array == 5) print(array &gt; 5) 数组元素累加：a.cumsum() 或者 np.cumsum(a) 数组元素累差：np.diff(a) 获取数组非零行列索引：np.nonzero(a) 对数组进行排序：np.sort(a) 数组里行列倒置：np.transpose(a) 或者 a.T 将数组抹平 a.flatten() # flatten()为功能函数，直接将二维数组抹平，但如果要进行循环迭代，用flat迭代器也可以 限定最大最小值（所有超过范围的都取最大或最小值）：a.clip(10, 20) 或者 np.clip(a, 10, 20) 在行上面加一个维度：a[np.newaxis, :] 在列上面加一个维度：a[:, np.newaxis] 数组的合并 A = np.array([[1, 1, 1], [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]]) B = np.array([[2, 2, 2], [&apos;d&apos;, &apos;e&apos;, &apos;f&apos;]]) 垂直合并 np.vstack((A, B)) # 每个数组每一行每一行地装上去 水平合并 np.hstack((A, B)) # 每个数组同一行先合并再装上去 指定维度的合并 np.concatenate((A, B), axis=0) # 一维数组axis只能为0 数组的分割 A = np.arange(12).reshape((3, 4)) 对等分割行 np.split(A, 3, axis=0) 或者 np.vsplit(A, 3) 对等分割列 np.split(A, 2, axis=1) 或者 np.hsplit(A, 2) 不等分割行 np.array_split(A, 2, axis=0) 不等分割列 np.array_split(A, 3, axis=1) 二维数组的索引 普通索引： a[2][0] 同一中括号索引： a[2, 0] 切片索引 a[2, :] # 第三行所有数 a[:, 2] # 第三列所有数 a[2, 1:] # 第三行第一位之后的所有数 a[1:, 2] # 第三列第一位之后的所有数 a[2, 1:3] # 第三行第一位到第三位的所有数 迭代行 for row in a: print(row) 迭代列 for column in a.T: print(column) 将数组抹平后迭代 for item in a.flat: print(item) 二维数组的运算： a = np.array([[0, 2],[1, 3]]) b = np.arange(8).reshape((2, 4)) 普通乘法： c = a * b 矩阵乘法： d = np.dot(a, b) 或者 d = a.dot(b) 数组中的复制： a = np.arange(12) 浅复制（改变数组a或b的元素的值，其它的跟着改变） b = a # b是a，指向同一个物理位置 深复制（改变数组a或b的元素的值，其它的不改变） b = a.copy() # b不是a，分别享有各自的物理位置 随机数 创建一个0~1随机数构成的2行4列的数组： a = np.random.random((2, 4)) 生成6个随机数： np.random.rand(6) 返回一个具有正在分布的随机数构成的6行4列的数组： np.random.randn(6, 4) 其他 函数装配vectorize()使得其函数可以应用在numpy数组上 lencount = np.vectorize(lambda x: len(x)) np.nan： 生成一个类型为float的NaN的空字符]]></content>
      <categories>
        <category>python</category>
        <category>numpy</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git的基础命令]]></title>
    <url>%2Fblog%2F2018%2F05%2F21%2Fgit%E7%9A%84%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。 Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。开发者：Linus Torvalds（同时也是linux的开发者，他是神↓） 确定管理文件夹 cd进入到该文件夹 确定身份象征(提交任何修改使用)：git config --global user.name &quot;&quot; git config --global user.email &quot;&quot; 查看身份象征：git config user.name git config user.email 初始化git管理目录：git init 查看隐藏文件：ls -a 创建文件：touch 1.py 查看git管理库状态 查看普通状态：git status 查看修改状态：git status -s git工作流程图 添加可提交修改（commited）文件（stage） 提交单个文件：git add 1.py 提交所有文件：git add . 撤销提交的文件：git reset 1.py 提交文件 直接提交：git commit -m &quot;提交信息&quot; 直接提交并添加：git commit -am &quot;提交信息&quot;（已经管理库有的文件，新文件无法识别到） 提交文件至上次提交的分支：git commit --amend（上次分支） --no-edit（不修改-m信息） 打印git日志 直接打印：git log 简洁打印：git log --oneline 简洁图形打印： git log --oneline --graph 查看修改信息 查看已修改未添加的修改信息：git diff 查看已添加的修改信息：git diff --cached 查看已添加再修改文件的修改信息：git diff HEAD 修改当前的头分支：git reset --hard (分支id号或HEAD指针（HEAD@{0}）) reset是在unstage(已commit)和stage之间重置） 重置单个文件的内容信息：git checkout 分支id号 -- 1.py 分支 创建分支：git branch dev 或者 git checkout -b dev(创建并移动到该分支) 查看分支：git branch 切换分支：git checkout dev 删除分支：git branch -d dev 合并分支：git merge --no-ff -m &quot;合并信息&quot; dev 合并分支：git rebase dev 暂存任务 暂存当前任务：git stash 取出暂存任务：git stash pop github 建立远程连接：git remote add origin xxxxxxxxxx.git 从远程取分支的更新并与本地指定分支结合：git pull origin remotebranch:localbranch 远程分支的更新与当前分支结合：git pull origin remotebranch 将本地分支上传到远程分支：git push -u origin master 将本地分支强制上传到远程分支：git push -fu origin master（覆盖掉远程分支的所有文件）]]></content>
      <categories>
        <category>git</category>
        <category>github</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
</search>
